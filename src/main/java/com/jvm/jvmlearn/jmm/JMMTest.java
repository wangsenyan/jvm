package com.jvm.jvmlearn.jmm;

/**
 * JMM模型
 * 一。定义
 * 1. 主内存
 *  - 堆中的实例对象部分
 *  - 包括实例字段、静态字段和构成数组对象的元素
 *  - 硬件的物理内存
 *  - 线程间变量传递
 *
 * 2. 工作内存
 *  - 栈中的部分区域
 *  - 包括局部变量和方法参数
 *  - 寄存器和高速缓存
 *  - 主内存副本拷贝
 *
 * 二。交互操作
 * 1. lock(锁定)
 *   - 作用域主内存的变量,把一个变量标识为线程独占状态
 * 2. unlock(解锁)
 *   - 作用于主内存的变量,把一个处于锁定状态的变量释放出来,
 *     释放后的变量才可以被其他线程锁定
 * 3. read(读取)
 *   - 作用于主内存变量,把一个变量的值从主内存传输到
 *     线程的工作内存中，以便随后的load动作使用
 * 4. load(载入)
 *   - 作用于工作内存的变量,它把read操作从主存中变量放入工作内存中
 * 5. use(使用)
 *   - 作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，
 *     每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令。
 * 6. assign(赋值)
 *   - 作用于工作内存中的变量，它把一个从执行引擎中接受到
 *     的值放入工作内存的变量副本中。
 * 7. store(存储)
 *   - 作用于主内存中的变量，它把一个从工作内存中一个变量
 *     的值传送到主内存中，以便后续的write使用。
 * 8. write(写入)
 *   - 作用于主内存中的变量，它把store操作从工作内存中得
 *     到的变量的值放入主内存的变量中。
 * 三。规则
 * 1. 主内存->read->load->工作内存->use->assign->工作内存->store->write->主内存
 * 2. 不允许read和load、store和write操作之一单独出现。
 * 3. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
 * 4. 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
 * 5. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
 * 6. 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
 * 7. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
 * 8. 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
 * 9. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）
 * 四。重排
 * 1. 源代码-》编译器优化重排序-》指令集并行重排序-》内存系统重排序-》最终执行指令序列
 *
 * 五。常见指令
 * 1，volatile
 *  - 可见性
 *  - 有序禁止重排
 *  - 不保证原子性
 * 2. 内存屏障 (Memory Barrier)
 *  - 通过插入内存屏障禁止在内存屏障前后的指令执行重排优化、
 * 3. 使用volatile的地方
 *  - 单例模式
 *  -
 */

public class JMMTest {
}
